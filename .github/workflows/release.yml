name: Auto Release

on:
  push:
    branches: [main]
  workflow_dispatch:  # allow manual re-runs

# Prevent concurrent releases
concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  # Wait for the CI workflow to pass before releasing
  ci:
    uses: ./.github/workflows/ci.yml

  release:
    needs: [ci]
    runs-on: ubuntu-latest
    environment: pypi
    # Skip if the commit was made by the release bot (prevents infinite loop)
    if: "!contains(github.event.head_commit.message, '[skip-release]')"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use the default GITHUB_TOKEN - needs "Allow GitHub Actions to
          # create and approve pull requests" enabled in repo settings, and
          # the default token permissions set to read/write.
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine bump type
        id: bump
        run: |
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          # Check for explicit bump directives in merge commit message
          if echo "$COMMIT_MSG" | grep -qiE '\[(major|bump-major)\]'; then
            echo "type=major" >> "$GITHUB_OUTPUT"
          elif echo "$COMMIT_MSG" | grep -qiE '\[(minor|bump-minor)\]'; then
            echo "type=minor" >> "$GITHUB_OUTPUT"
          else
            echo "type=patch" >> "$GITHUB_OUTPUT"
          fi
          echo "Bump type: $(cat "$GITHUB_OUTPUT" | grep type | cut -d= -f2)"

      - name: Bump version
        id: version
        run: |
          python - <<'PYEOF'
          import re, os, sys

          bump_type = os.environ["BUMP_TYPE"]

          with open("pyproject.toml") as f:
              content = f.read()

          m = re.search(r'version\s*=\s*"(\d+)\.(\d+)\.(\d+)"', content)
          if not m:
              print("ERROR: Could not find version in pyproject.toml")
              sys.exit(1)

          major, minor, patch = int(m.group(1)), int(m.group(2)), int(m.group(3))
          old_version = f"{major}.{minor}.{patch}"

          if bump_type == "major":
              major += 1
              minor = 0
              patch = 0
          elif bump_type == "minor":
              minor += 1
              patch = 0
          else:
              patch += 1

          new_version = f"{major}.{minor}.{patch}"
          content = content.replace(f'version = "{old_version}"', f'version = "{new_version}"')

          with open("pyproject.toml", "w") as f:
              f.write(content)

          print(f"Bumped {old_version} -> {new_version} ({bump_type})")

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"old_version={old_version}\n")
              f.write(f"new_version={new_version}\n")
              f.write(f"tag=v{new_version}\n")
          PYEOF
        env:
          BUMP_TYPE: ${{ steps.bump.outputs.type }}

      - name: Commit version bump via API
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.version.outputs.new_version }}
        run: |
          # Read the updated file content
          CONTENT=$(base64 -w0 pyproject.toml)

          # Get the current commit SHA and tree
          MAIN_SHA=$(gh api repos/${{ github.repository }}/git/ref/heads/main --jq '.object.sha')
          TREE_SHA=$(gh api repos/${{ github.repository }}/git/commits/${MAIN_SHA} --jq '.tree.sha')

          # Get the blob SHA for pyproject.toml in the current tree
          OLD_BLOB_SHA=$(gh api "repos/${{ github.repository }}/git/trees/${TREE_SHA}" --jq '.tree[] | select(.path=="pyproject.toml") | .sha')

          # Create a new blob with the updated content
          NEW_BLOB_SHA=$(gh api repos/${{ github.repository }}/git/blobs \
            -f content="${CONTENT}" \
            -f encoding=base64 \
            --jq '.sha')

          # Create a new tree replacing pyproject.toml
          NEW_TREE_SHA=$(gh api repos/${{ github.repository }}/git/trees \
            -f "base_tree=${TREE_SHA}" \
            -f "tree[][path]=pyproject.toml" \
            -f "tree[][mode]=100644" \
            -f "tree[][type]=blob" \
            -f "tree[][sha]=${NEW_BLOB_SHA}" \
            --jq '.sha')

          # Create the commit
          COMMIT_SHA=$(gh api repos/${{ github.repository }}/git/commits \
            -f "message=release: v${NEW_VERSION} [skip-release]" \
            -f "tree=${NEW_TREE_SHA}" \
            -f "parents[]=${MAIN_SHA}" \
            --jq '.sha')

          # Update main ref
          gh api repos/${{ github.repository }}/git/refs/heads/main \
            -X PATCH \
            -f "sha=${COMMIT_SHA}" \
            -F "force=false"

          # Create the tag
          TAG_SHA=$(gh api repos/${{ github.repository }}/git/tags \
            -f "tag=v${NEW_VERSION}" \
            -f "message=v${NEW_VERSION}" \
            -f "object=${COMMIT_SHA}" \
            -f "type=commit" \
            --jq '.sha')

          gh api repos/${{ github.repository }}/git/refs \
            -f "ref=refs/tags/v${NEW_VERSION}" \
            -f "sha=${TAG_SHA}"

          echo "Created commit ${COMMIT_SHA} and tag v${NEW_VERSION}"

          # Update local checkout for the build step
          git fetch origin main --tags
          git checkout "v${NEW_VERSION}"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build

      - name: Build package
        run: python -m build

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          print-hash: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ steps.version.outputs.new_version }}"
          name: "v${{ steps.version.outputs.new_version }}"
          body: |
            ## mattstash v${{ steps.version.outputs.new_version }}

            Bumped from v${{ steps.version.outputs.old_version }} â†’ v${{ steps.version.outputs.new_version }} (${{ steps.bump.outputs.type }}).

            Install or upgrade:
            ```
            pip install mattstash==${{ steps.version.outputs.new_version }}
            ```
          generate_release_notes: true
